#!/bin/bash
########################################################################
## Useful simple functions
########################################################################

function caterr { cat "$@" >&2; }
function echoerr { echo "$@" >&2; }

########################################################################
## Do some calculation with bc
########################################################################
function bcalc {
bc -lq $@
}

## This function loads xbc extensions first
function bcxt {
bc -lq ~/.local/share/bc/extensions.bc $@
}

## This function loads xbc extensions and xbc
## scientific constants
function bcsc {
bc -lq ~/.local/share/bc/extensions.bc ~/.local/share/bc/scientific_constants.bc $@
}

########################################################################
## igdl specifics
########################################################################
## This function remove pattern $2 from file $1
function rmfrlist
{
  if [ $# -eq 2 ]; then
    ## remove pattern $2 from file $1
    cat "$1" | grep -v "$2" > tmp.txt
    ## Overwriting the original file with filtered file
    cat tmp.txt > "$1"
    rm tmp.txt
  else
    echo "usage: rmfrlist <file> <pattern>"
    echo "For example, to remove any trace of tawan_v from file randomlist:"
    echo "~$ rmfrlist randomlist tawan_v"
  fi
}

########################################################################
## Some extras
########################################################################

## This function makes qr code of text $2, then it
## displays the resulting qrcode.
function qrquick
{
  if [ $# -eq 2 ]; then
    qrencode -s 12 -m 1 -o $1.png "$2";
    display $1.png
  else
    echo "usage: qrquick <output> <text>"
  fi
}

## ssl encryption function

function ssl-encrypt
{
  if [ $# -eq 2 ]; then
    openssl enc -aes-256-cbc -a -salt -in $1 -out $2
  else
    echo "usage: ssl-encrypt <source> <destination>"
  fi
}

function ssl-decrypt
{
  if [ $# -eq 2 ]; then
    openssl enc -aes-256-cbc -d -a -in $1 -out $2
  else
    echo "usage: ssl-decrypt <source> <destination>"
  fi
}

## Wrapper for mpv and some fancy tasks such as building a playlist

mplay(){
# Default states
mplay_exit_state=0
mplay_watch_mode=0
mplay_list_mode=0
mplay_playlist="play.list"

# Argument parser
while :;
do
  case $1 in
    w|watch) # watch mode switch
      mplay_watch_mode=1
      shift
      ;;
    l|list|updatelist) # list mode switch
      mplay_list_mode=1
      shift
      ;;
    -p | --playlist )
      if test -z "$2"
      then
        printf >&2 "Error! No playlist file given!\n"
        mplay_exit_state=1
        break
      else
        mplay_playlist="$2"
        shift 2
      fi
      ;;
    -h | --help ) # Display help text
      printf "function mplay() - convenience function to play media files.\n\nTo use:\n"
      printf "\tmplay <w/l> [-p,--playlist FILE]\n\n"
      printf "Arguments:\n"
      printf "\tw,watch             Watch from playlist file\n"
      printf "\tl,list,updatelist   Update playlist file\n"
      printf "\t-p,--playlist FILE  Supply a custom playlist file\tDefault: play.list\n"
      printf "\t-h,--help           Display this help text\n"
      printf "\n"
      mplay_exit_state=-1
      break
      ;;
    "") # no more arguments
      break
      ;;
    * ) # some unexpected arguments
      printf >&2 "Error! Unexpected argument %s\n" "$1"
      mplay_exit_state=2
      break
      ;;
  esac
done

if test $mplay_list_mode -eq 0 -a $mplay_watch_mode -eq 0 -a $mplay_exit_state -eq 0
then
  printf >&2 "Error! Neither watch mode or list mode is active!\n\tUsage: mplay -h\n"
  mplay_exit_state=3
fi

# Exit state is okay
if test $mplay_exit_state -eq 0
then
  # List mode is always parsed first, so we will always have something to play
  if test $mplay_list_mode -eq 1
  then # Update playlist file
    ls|grep -i "mkv$\|mp4$" |tee "${mplay_playlist}"
  fi
  # Watch mode, run mpv using mplay_playlist file
  if test $mplay_watch_mode -eq 1
  then # Play the playlist file
    mpv --playlist="${mplay_playlist}"
  fi
elif test $mplay_exit_state -ne -1
then
  printf "Error status: %s\n" "$mplay_exit_state"
fi
}

## A very useful notetaking function that stores notes in ~/.notes
## Obtained from https://unix.stackexchange.com/a/59979/282465
# To make the code compatible for both zsh and bash
type emulate >/dev/null 2>/dev/null || alias emulate=true

# If ~/.notes does not exist, create one
test ! -d ~/.notes && mkdir ~/.notes

# Notetaking function. To use:
#   n file ...
# Can be any number of files
function n() {
  emulate -L ksh
  local arg; typeset -a files
  for arg; do files+=( ~/".notes/$arg" ); done
  ${EDITOR:-nano} "${files[@]}" 
}

## A compliment of above, list contents of our note storage
function nls() {
  tree -CR --noreport $HOME/.notes | awk '{ 
      if (NF==1) print $1; 
      else if (NF==2) print $2; 
      else if (NF==3) printf "  %s\n", $3 
    }'
}

## Specific functions to get user agents from our server

uaput(){
case $1 in
"")
  target=ytua
  ;;
*)
  target=$1
  ;;
esac

ftp ftp.xenomancy.id <<EOF
cd xenoagents/agents
put $target
bye
EOF
}

uaget(){
case $1 in
"")
  target=ytua
  ;;
*)
  target=$1
  ;;
esac

ftp ftp.xenomancy.id <<EOF
cd xenoagents/agents
get $target
bye
EOF
}
